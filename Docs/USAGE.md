## Команды в текстовом интерфейсе

### set_level [level] [unit]

Установить уровень сигнала в милливольтах RMS.

> Данная команда предполагает, что подключена нагрузка с сопротивлением 50 ом.
>
> Когда нагрузки нет, уровень будет выше заданного.

Изменение уровня применяется только к новым сигналам и не затрагивает находящиеся в очереди сигналы.

Пример: `set_level 200 mV`

### dbg_level [asf] [fsc]

Вручную установить значения ASF и FSC, которые определяют уровень сигнала в AD9910. Можно использовать в отладочных целях.

Пример: `dbg_level 16383 0`

### test_tone [freq] [unit]

Подача непреревного сигнала на указанной частоте.

Пример: `test_tone 159.0 MHz`

![test_tone 159 MHz](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/b8247705-0dce-4c52-bee0-04f8d200ca63)

### basic_pulse [offset] [unit] [duration] [unit] [freq] [unit]

Подача импульсов некоторой длительности на некоторой частоте, с некоторым отступом от триггера.

Пример: `basic_pulse 0 us 18000 us 159.0 MHz`

![basic_pulse 0 us 18000 us 159 MHz](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/811c9247-69cc-470e-939c-28d8a6da24cb)

### basic_sweep [offset] [unit] [duration] [unit] [center_freq] [unit] [a] [b]

Свипы некоторой продолжительности, с некоторым отступом от триггера, на некоторой центральной частоте, с некоторой общей полосой.

|Параметр|Значение|
|---|---|
|a|Величина шага в единицах FTW|
|b|Делитель частоты шагов|

Полоса вычисляется следующим образом:

```
steps = duration * 250 MHz / b
band = a * (1 GHz / 2^32) * (steps - 1)
```

Если a положительное, то частота свипа будет нарастающая, т.е. конечная частота выше начальной. Если же a отрицательное, то частота свипа будет убывающая, когда конечная частота ниже начальной.

Пример свипа с положительным a: `basic_sweep 0 us 18000 us 159.0 MHz 1 1`

![basic_sweep 0 us 18000 us 159 0 MHz 1 1](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/42b9fbb8-24d8-41ef-bb70-10d8a34ef350)

Привер свипа с отрицательным a: `basic_sweep 0 us 18000 us 159.0 MHz -1 1`

![basic_sweep 0 us 18000 us 159 MHz -1 1](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/dad0410a-4e60-432f-98e3-4a42e0b2e1b7)

Вот некоторые возможные комбинации a и b:

|duration|a|b|Полоса|
|---|---|---|---|
|18000 us|1|1|~1.04773 MHz|
|900 us|1|1|~52.386 kHz|
|900 us|10|1|~0.52386 MHz|
|900 us|20|1|~1.04773 MHz|

Можно получить значения с меньшим количеством знаков после запятой, если использовать длительность, равную степени двойки + 4ns:

|duration|a|b|Полоса|
|---|---|---|---|
|2^20ns + 4ns|128|1|7.8125 MHz|
|2^20ns + 4ns|256|1|15.625 MHz|
|2^20ns + 4ns|512|1|31.25 MHz|

Также допустимо создание свипов с очень маленьким количеством шагов. Например, свип с величиной шага a = 42949673 (Примерно 10 МГц), делителем частоты шагов b = 22500, длительностью 900 мкс и центральной частотой 150 МГц будет содержать всего десять частотных составляющих, каждая длительностью 90 мкс:

```
1  105 МГц
2  115 МГц
3  125 МГц
4  135 МГц
5  145 МГц
6  155 МГц
7  165 МГц
8  175 МГц
9  185 МГц
10 195 МГц
```

## basic_xmitdata ram_psk [offset] [unit] [freq] [unit] [element_duration] [unit] [...]

Подача импульсов с BPSK модуляцией с использованием оперативной памяти AD9910.

Максимальная длительность элемента составляет 4 / (1 GHz) * 65535 = ~262мкс. Если нужно больше, то можно составить два или более одинаковых элемента друг за другом.

Общая продолжительность сигнала определяется исходя из количества элементов и длительности одного элемента.

Элементы кода записываюся после основной команды и могут быть равны 0 либо 1, где 0 - нет сдвига фазы, а 1 - фаза сдвинута на 180 градусов.

Максимальное количество элементов в коде составляет 1023. Всего оперативная память AD9910 может вместить 1024 элемента, но последний элемент зарезервирован для прерывания сигнала.

Пример: `basic_xmitdata ram_psk 0 us 159.0 MHz 200 us 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0`

![basic_xmitdata ram_psk 0 us 159 0 MHz 200 us 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/9d44b6c3-7886-439b-b150-7b878d2c6e5a)

## seq [...]

Команды секвенсора позволяют задавать последовательности из разных сигналов. При воспроизведении последовательность в секвенсоре повторяется бесконечно.

|Команда|Пояснение|
|---|---|
|seq pulse [...]|Добавить сигнал с фиксированной частотой в конец очереди; порядок аргументов идентичен basic_pulse|
|seq sweep [...]|Добавить свип в конец очереди; порядок аргументов идентичен basic_sweep|
|seq run|Запустить воспроизведение|
|seq stop|Остановить воспроизведение|
|seq reset|Очистить очередь|

Пример:

```
seq sweep 0 us 18000 us 159.0 MHz 1 1
seq pulse 0 us 18000 us 159.524 MHz
seq sweep 0 us 18000 us 159.0 MHz -1 1
seq pulse 0 us 18000 us 158.476 MHz
seq run
```

![sequencer](https://github.com/AXKuhta/stm32_ad9910/assets/11133304/f3c8a885-f8eb-494d-8bab-78471956a0b9)

## radar_emulator [freq] [unit] [duration] [unit] [count]

Задать частоту следования триггеров от внутреннего источника, их длительность, и, опционально, количество.

Последний аргумент - количество - является опциональным. Если не указывать его, то импульсы будут создаваться бесконечно. Если указать 0, то внутренний источник триггеров будет выключен. Если задать ненулевое значение, то источник сделает столько импульсов и отключится.

Пример для бесконечного потока импульса: `radar_emulator 25 Hz 12 us`
Пример для только трёх импульсов: `radar_emulator 25 Hz 12 us 3`
